---
title: "分布式学习手记09 - ZooKeeper 核心技术（下）"
categories:
  - 分布式
date: 2019-1-9
toc: true
toc_label: "核心技术"
toc_icon: "align-left"
header:
  teaser: /assets/images/fbs_teaser.gif
---

> ZooKeeper 的核心技术细节第三部分，包括：请求处理、数据与存储。

## 请求处理

ZooKeeper 如何处理客户端发起的一次请求

### 会话创建请求

ZooKeeper 服务端对于会话创建的处理，分为请求接收、会话创建、预处理、事务处理、事务应用和会话响应 6 个环节

- 请求接收

  1. I/O 层接收来自客户端的请求

     由 NIOServerCnxn 负责接收来自客户端的所有请求，并将请求内容从底层网络 I/O 中完整读取出来

  2. 判断是否是客户端 “会话创建” 请求

     请求对应的 NIOServerCnxn 实体若没被初始化，则该请求是 “会话创建” 请求

  3. 反序列化 ConnectRequest 请求

     对此会话创建请求反序列化，生成一个 ConnectRequest 实体

  4. 判断是否是 ReadyOnly 客户端

  5. 检查客户端 ZXID

     若客户端 ZXID 大于服务端 ZXID，拒绝该请求

  6. 协商 sessionTimeout

  7. 判断是否需要重新创建会话

     若客户端请求已包含 sessionID，确定为会话重连，重新打开会话，否则需要重新创建会话

- 会话创建

  8. 为客户端生成 sessionID

     由会话管理器 SessionTracker 为每个会话维护全局唯一的 “基准 sessionID”，以此递增

  9. 向 SessionTracker 注册会话

     sessionsWithTimeout 根据 sessionID 保存所有会话超时时间；

     sessionsById 根据 sessionID 保存所有会话实体

  10. 激活会话

  11. 生成会话密码

- 预处理

  12. 请求提交给 PrepRequestProcessor 处理

  13. 创建请求事务头

  14. 创建请求事务体

  15. 注册与激活会话

- 事务处理

  16. 请求交给 ProposalRequestProcessor 处理

      - Sync 流程

        由 SyncRequestProcessor 记录事务日志

      - Proposal 流程

        事务请求需通过半数以上的节点投票，投票与统计的过程即 Proposal 流程

        1. Leader 服务器发起事务投票

        2. 生成提议 Proposal

        3. 广播提议

        4. 收集投票

        5. 将请求放入 toBeApplied 队列

        6. 广播 COMMIT 消息

      - Commit 流程

        1. 请求交付给 CommitProcessor

           先不处理，存入 queuedRequests 队列

        2. 处理 queuedRequests 队列中的请求

        3. 标记 nestPending

        4. 等待 Proposal 投票

        5. 投票通过

        6. 提交请求

- 事务应用

  17. 交付给 FinalRequestProcessor

  18. 事务应用

      将事务变更应用到内存数据库

  19. 将事务请求放入 commitProposal 队列

      commitProposal 队列保存最近被提交的事务请求，以便集群内机器进行数据的快速同步

- 会话响应

  20. 统计处理

  21. 创建响应 ConnectResponse

      ConnectResponse 是会话创建成功后的响应

  22. 序列化 ConnectResponse

  23. I/O 层发送响应给客户端
