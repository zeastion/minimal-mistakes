---
title: "分布式学习手记07 - ZooKeeper 核心技术"
categories:
  - 分布式
date: 2018-12-11
toc: true
toc_label: "典型应用场景"
toc_icon: "align-left"
header:
  teaser: /assets/images/fbs_teaser.gif
---

> ZooKeeper 的核心技术细节，包括：系统模型、序列化与协议、客户端工作原理、会话、服务端工作原理以及数据存储等方面。

## 系统模型

数据模型、节点特性、版本、Watcher 和 ACL

### 数据模型

- ZNode

  ZNode 是 ZooKeeper 中最小数据单元，可以保存数据或挂载子节点

- 树

  多个 ZNode 按层次化结构进行组织，形成一棵树

- 事务ID

  每一个事务会分配一个全局唯一的事务ID（ZXID），共 64 位，包含事务标识和事务顺序两部分

### 节点特性

- 类型

  1. 持久节点

  2. 持久顺序节点

  3. 临时节点 - 随客户端会话失效而销毁；不能基于临时节点创建子节点

  4. 临时顺序节点

- 状态信息

  ZNode 上存储数据内容外，还存储数据节点的状态信息


```bash
[zk: localhost:2181(CONNECTED) 3] get /zk-book
123
cZxid = 0x200000004
ctime = Tue Jun 26 11:26:02 CST 2018
mZxid = 0x200000004
mtime = Tue Jun 26 11:26:02 CST 2018
pZxid = 0x200000004
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 3
numChildren = 0
```

### 版本

ZooKeeper 中的版本表示的是对数据节点的数据内容、子节点列表，或是节点 ACL 信息的修改次数。

实现类似于乐观锁机制中的 "写入校验" ，保证分布式数据操作的原子性。

- version - 当前数据节点数据内容的版本号

- cversion - 当前数据节点子节点的版本号

- aversion - 当前数据节点 ACL 变更版本号

### Watcher

实现分布式系统中的变更通知功能

- 流程机制

  1. 客户端向 ZooKeeper 服务器注册 Watcher，同时将 Watcher 对象存储在客户端的 WatchManager 中；

  2. ZooKeeper 服务端触发 Watcher 事件后，向客户端发送通知；

  3. 客户端线程从 WatchManager 中取出对应的 Watcher 对象来执行回调逻辑。

- 特性

  1. 一次性

     Watcher 一旦触发使用完，移除销毁

  2. 客户端串行执行

     客户端 Watcher 回调串行同步，保证顺序

  3. 轻量

     ZooKeeper 服务端发送的 Watcher 通知仅告诉客户端发生了事件，不含事件具体内容；

     客户端注册 Watcher 时，不会上传真实的 Watcher 对象，而是存储在客户端的 WatchManager 里

### ACL

ZooKeeper 提供一套完善的 ACL（Access Control List）权限控制机制来保障数据的安全

更细粒度的权限管理方式  'scheme:id:permission'

- 权限模式 Scheme

  权限验证过程中使用的验证策略： IP、Digest、World、Super

- 授权对象 ID

  权限赋予的用户或一个指定实体

- 权限 Permission

  通过权限检查后可以被允许执行的操作： CREATE、 DELETE、READ、WRITE、ADMIN


## 序列化与协议

ZooKeeper 客户端和服务端之间会进行一系列网络通信以实现数据的传输。对于网络通信，首要解决对数据的序列化和反序列化处理。

### Jute

Jute 是 ZooKeeper 的序列化组件

- Record 接口

  1. 序列化方法： serialize

  2. 反序列化方法： deserialize

- 序列化器

  1. 序列化器： OutputArchive

  2. 反序列化器： InputArchive

- Jute 配置文件

  - zookeeper.jute

### 通信协议

ZooKeeper 基于 TCP/IP 实现了自己的通信协议

- 请求

  1. 请求头 RequestHeader (xid & type)

  2. 请求体 Request （请求的所有操作内容）

- 响应

  1. 响应头 ReplyHeader (xid & zxid & err)

  2. 响应体 Response (响应的所有返回数据)

## 客户端

客户端主要组件

- ZooKeeper 实例： 客户端的入口

- ClientWatchManager： 客户端 Watcher 管理器

- HostProvider： 客户端地址列表管理器

- ClientCnxn： 客户端核心线程

### 一次会话的创建过程

客户端一次会话创建过程示例

- 初始化阶段

  1. 初始化 ZooKeeper 对象

     实例化一个 ZooKeeper 对象；

     创建一个客户端的 Watcher 管理器：ClientWatchManager

  2. 设置会话默认 Watcher

     将构造方法中传入的 Watcher 对象存入 ClientWatchManager

  3. 构造服务器地址列表管理器： HostProvider

     将构造方法中传入的服务器地址，存入 HostProvider

  4. 创建并初始化客户端网络连接器： ClientCnxn

     客户端创建一个网络连接器 ClientCnxn 来管理客户端和服务器的网络交互；

     创建客户端的请求发送队列 outgoingQueue，服务端响应的等待队列 pendingQueue；

     创建底层 I/O 处理器： ClientCnxnSocket

  5. 初始化核心网络线程 SendThread 和 EventThread

     - SendThread： 管理客户端和服务器之间所有网络 I/O

       使用 ClientCnxnSocket 作为底层网络 I/O 处理器

     - EventThread： 客户端的事件处理

       初始化待处理事件队列 waitingEvents 用于存放所有等待被客户端处理的事件

- 会话创建阶段

  6. 启动 SendThread 和 EventThread

  7. 获取服务器地址

     SendThread 从 HostProvider 中随机获取一个 ZooKeeper 服务器地址

  8. 创建 TCP 连接

     ClientCnxnSocket 负责和服务器创建一个 TCP 长连接

  9. 构造 ConnectRequest 请求

     SendThread 根据当前客户端实际设置，构造出 ConnectRequest 请求，即表示客户端试图与服务器创建一个会话；

     客户端进一步将该请求包装成网络 I/O 层的 Packet 对象，放入请求发送队列 outgoingQueue

  10. 发送请求

      ClientCnxnSocket 负责从 outgoingQueue 中取出一个待发送的 Packet 对象，将其序列化成 ByteBuffer 后，向服务端发送

- 响应处理阶段

  11. 接收服务端响应

      ClientCnxnSocket 对接收到的服务端响应进行判断

  12. 处理 Response

      ClientCnxnSocket 会对接收到的服务端响应反序列化，得到 ConnectResponse 对象，并从中获取到 ZooKeeper 服务端分配的会话 sessionId

  13. 连接成功

      通知 SendThread 线程，进一步对客户端进行会话参数的设置，并更新客户端状态；

      通知 HostProvider 当前成功连接的服务器地址

  14. 生成事件： SyncConnected-None

      SendThread 生成一个事件 SyncConnected-None，代表客户端和服务器会话创建成功，并将该事件传递给 EventThread，从而让上层应用感知到会话的成功创建

  15. 查询 Watcher

      EventThread 线程收到事件后，会从 ClientWatchManager 中查询对应的 Watcher，将其放到 EventThread 的 waitingEvents 队列中去

  16. 处理事件

      EventThread 不断从 waitingEvents 队列中取出待处理的 Watcher 对象，对其触发处理
